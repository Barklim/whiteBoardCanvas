{"version":3,"sources":["modules/core/RenderLoop.ts","modules/core/camera-utils.ts","modules/core/constants.ts","modules/core/math-utils.ts","modules/state/CanvasStore.ts","modules/core/foundation.tsx","modules/editor/InfiniteCanvas.tsx","modules/editor/CanvasRoot.tsx","modules/editor/Editor.tsx","index.tsx"],"names":["renderLoop","cameraToScreenCoordinates","x","y","z","cameraAngle","screenAspect","width","Math","tan","height","CAMERA_ANGLE","PI","getInitialCanvasState","shouldRender","pixelRatio","window","devicePixelRatio","container","pointer","camera","canvasData","CanvasStore","_classCallCheck","this","_createClass","key","value","containerWidth","containerHeight","cameraX","cameraY","cameraZ","mx","my","deltaX","deltaY","_this$camera","isCameraInBounds","data","movePointer","anchorPointX","anchorPointY","cameraX1","cameraY1","scaleX1","scaleY1","scaleX2","scaleY2","deltaAmount","max","_this$camera2","oldX","oldY","oldZ","oldScale","_objectSpread","scale","_this$container","_cameraToScreenCoordi","aspect","newScaleX","newScaleY","_scaleWithAnchorPoint","newX","newY","newZ","_this$screen","screen","left","top","get","_this$camera3","_CanvasStore$screen","w","h","_CanvasStore$containe","set","Position","_ref","rect1","rect2","children","React","createElement","className","style","concat","TextBlock","text","color","background","memo","_ref2","frame","createCustomSequenceArray","sequence","length","result","i","push","texts","colors","transform","transformOrigin","map","index","floor","RenderLoop","fps","arguments","undefined","draw","lastFrameTime","lastRequestId","performance","now","loop","cancelAnimationFrame","_this","requestAnimationFrame","elapsed","fpsInterval","useRenderLoop","_useState","useState","_useState2","_slicedToArray","setFrame","useRef","getRenderLoop","useEffect","current","start","stop","wheelListener","e","event","ctrlKey","zoomCamera","moveCamera","pointerListener","console","log","clientX","clientY","CanvasRoot","canvas","_useSize","useSize","_useSize2","initialize","isPointerDown","ref","onWheel","onPointerDown","startX","startY","scrollListener","document","addEventListener","stopScrollListener","removeEventListener","onPointerUp","onPointerMove","InfiniteCanvas","Editor","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.4b50a612.chunk.js","sourcesContent":["import CanvasStore from \"../../modules/state/CanvasStore\";\nimport { useEffect, useRef, useState } from \"react\";\n\nclass RenderLoop {\n  private lastFrameTime: number = 0;\n  private lastRequestId: number | null = null;\n  constructor(private fps: number = 0, private draw: () => void) {}\n\n  initialize(fps: number) {\n    this.fps = fps;\n  }\n\n  start() {\n    this.lastFrameTime = performance.now();\n    this.loop();\n  }\n\n  stop() {\n    if (this.lastRequestId) cancelAnimationFrame(this.lastRequestId);\n    this.lastRequestId = null;\n  }\n\n  private get fpsInterval() {\n    return 1000 / this.fps;\n  }\n\n  private loop() {\n    this.lastRequestId = requestAnimationFrame(() => this.loop());\n    const now = performance.now();\n    const elapsed = now - this.lastFrameTime;\n    if (elapsed > this.fpsInterval) {\n      this.lastFrameTime = now - (elapsed % this.fpsInterval);\n      this.draw();\n    }\n  }\n}\n\nlet renderLoop: RenderLoop;\nexport function getRenderLoop(fps = 15, draw: () => void) {\n  if (!renderLoop) return new RenderLoop(fps, draw);\n  else return renderLoop;\n}\n\nexport const useRenderLoop = (fps: number = 15) => {\n  const [frame, setFrame] = useState(\"0\");\n  const loop = useRef<RenderLoop>(\n    getRenderLoop(fps, () => {\n      if (CanvasStore.shouldRender) {\n        setFrame(`${performance.now()}`);\n        CanvasStore.shouldRender = false;\n      }\n    })\n  );\n\n  useEffect(() => {\n    CanvasStore.shouldRender = true;\n    loop.current.start();\n\n    return () => loop.current.stop();\n  }, []);\n  return frame;\n};\n\nexport default useRenderLoop;\n","export const cameraToScreenCoordinates = (\n  x: number,\n  y: number,\n  z: number,\n  cameraAngle: number,\n  screenAspect: number\n) => {\n  const width = 2 * z * Math.tan(cameraAngle);\n  const height = width / screenAspect;\n  const screenX = x - width / 2;\n  const screenY = y - height / 2;\n  return { x: screenX, y: screenY, width, height };\n};\n\n// After changing scale, we return an x y position so that the relative position from top left remains constant\n// This way, after zooming, we make sure to set x and y so that users pointer position remains unchanged\nexport const scaleWithAnchorPoint = (\n  anchorPointX: number,\n  anchorPointY: number,\n  cameraX1: number,\n  cameraY1: number,\n  scaleX1: number,\n  scaleY1: number,\n  scaleX2: number,\n  scaleY2: number\n) => {\n  const cameraX2 =\n    (anchorPointX * (scaleX2 - scaleX1) + scaleX1 * cameraX1) / scaleX2;\n  const cameraY2 =\n    (anchorPointY * (scaleY2 - scaleY1) + scaleY1 * cameraY1) / scaleY2;\n\n  return { x: cameraX2, y: cameraY2 };\n};\n","import { radians } from \"./math-utils\";\n\nexport const CAMERA_ANGLE = radians(30);\nexport const RECT_W = 1000;\nexport const RECT_H = 1000;\n","export const radians = (angle: number) => {\n  return angle * (Math.PI / 180);\n};\n\ninterface Rect {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n}\n\nexport const inBounds = (rect1: Rect, rect2: Rect) => {\n  if (\n    rect1.left < rect2.left + rect2.width &&\n    rect1.left + rect1.width > rect2.left &&\n    rect1.top < rect2.top + rect2.height &&\n    rect1.top + rect1.height > rect2.top\n  )\n    return true;\n  else return false;\n};\n","import {\n  cameraToScreenCoordinates,\n  scaleWithAnchorPoint,\n} from \"../core/camera-utils\";\nimport { CAMERA_ANGLE, RECT_H, RECT_W } from \"../core/constants\";\n// import { radians } from \"../core/math-utils\";\n\nexport interface CanvasState {\n  shouldRender: boolean;\n  pixelRatio: number; // our resolution for dip calculations\n  container: {\n    //holds information related to our screen container\n    width: number;\n    height: number;\n  };\n  pointer: {\n    x: number;\n    y: number;\n  };\n  camera: {\n    //holds camera state\n    x: number;\n    y: number;\n    z: number;\n  };\n}\nconst getInitialCanvasState = (): CanvasState => {\n  return {\n    shouldRender: true,\n    pixelRatio: window.devicePixelRatio || 1,\n    container: {\n      width: 0,\n      height: 0,\n    },\n    pointer: {\n      x: 0,\n      y: 0,\n    },\n    camera: {\n      x: 0,\n      y: 0,\n      z: 0,\n    },\n  };\n};\n\nlet canvasData = getInitialCanvasState();\n\nexport default class CanvasStore {\n  private static get data() {\n    if (!canvasData)\n      canvasData = {\n        shouldRender: true,\n        pixelRatio: window.devicePixelRatio || 1,\n        container: {\n          width: 0,\n          height: 0,\n        },\n        pointer: {\n          x: 0,\n          y: 0,\n        },\n        camera: {\n          x: 0,\n          y: 0,\n          z: 0,\n        },\n      };\n    return canvasData;\n  }\n\n  static initialize(width: number, height: number) {\n    const containerWidth = width;\n    const containerHeight = height;\n    canvasData = getInitialCanvasState();\n    canvasData.pixelRatio = window.devicePixelRatio || 1;\n    canvasData.container.width = containerWidth;\n    canvasData.container.height = containerHeight;\n    canvasData.camera.x = 1.5 * RECT_W;\n    canvasData.camera.y = 1.5 * RECT_H;\n    canvasData.camera.z = containerWidth / (2 * Math.tan(CAMERA_ANGLE));\n  }\n  public static get screen() {\n    const { x, y, z } = this.camera;\n    const aspect = this.aspect;\n    const angle = CAMERA_ANGLE;\n    return cameraToScreenCoordinates(x, y, z, angle, aspect);\n  }\n  public static get camera() {\n    return this.data.camera;\n  }\n  public static get scale() {\n    const { width: w, height: h } = CanvasStore.screen;\n    const { width: cw, height: ch } = CanvasStore.container;\n    return { x: cw / w, y: ch / h };\n  }\n  public static get shouldRender() {\n    return canvasData.shouldRender;\n  }\n  public static set shouldRender(value: boolean) {\n    canvasData.shouldRender = value;\n  }\n\n  private static get container() {\n    return canvasData.container;\n  }\n\n  private static get pointer() {\n    return canvasData.pointer;\n  }\n\n  private static get aspect() {\n    return canvasData.container.width / canvasData.container.height;\n  }\n\n  private static isCameraInBounds(\n    cameraX: number,\n    cameraY: number,\n    cameraZ: number\n  ) {\n    return true;\n    // const angle = radians(30);\n    // const { x, y, width, height } = cameraToScreenCoordinates(\n    //   cameraX,\n    //   cameraY,\n    //   cameraZ,\n    //   angle,\n    //   this.aspect\n    // );\n    // const isXInBounds = x >= 0 && x <= this.data.canvas.width;\n    // const isYInBounds = y >= 0 && y <= this.data.canvas.height;\n    // return isXInBounds && isYInBounds;\n  }\n\n  public static moveCamera(mx: number, my: number) {\n    const scrollFactor = 1.5;\n    const deltaX = mx * scrollFactor,\n      deltaY = my * scrollFactor;\n    const { x, y, z } = this.camera;\n    if (this.isCameraInBounds(x + deltaX, y + deltaY, z)) {\n      this.data.camera.x += deltaX;\n      this.data.camera.y += deltaY;\n      // move pointer by the same amount\n      this.shouldRender = true;\n      this.movePointer(deltaY, deltaY);\n    }\n  }\n\n  public static zoomCamera(deltaX: number, deltaY: number) {\n    // Normal zoom is quite slow, we want to scale the amount quite a bit\n    const zoomScaleFactor = 10;\n    const deltaAmount = zoomScaleFactor * Math.max(deltaY);\n    const { x: oldX, y: oldY, z: oldZ } = this.camera;\n    const oldScale = { ...this.scale };\n\n    const { width: containerWidth, height: containerHeight } = this.container;\n    const { width, height } = cameraToScreenCoordinates(\n      oldX,\n      oldY,\n      oldZ + deltaAmount,\n      CAMERA_ANGLE,\n      this.aspect\n    );\n    const newScaleX = containerWidth / width;\n    const newScaleY = containerHeight / height;\n    const { x: newX, y: newY } = scaleWithAnchorPoint(\n      this.pointer.x,\n      this.pointer.y,\n      oldX,\n      oldY,\n      oldScale.x,\n      oldScale.y,\n      newScaleX,\n      newScaleY\n    );\n    const newZ = oldZ + deltaAmount;\n    this.shouldRender = true;\n    if (this.isCameraInBounds(oldX, oldY, newZ)) {\n      this.data.camera = {\n        x: newX,\n        y: newY,\n        z: newZ,\n      };\n    }\n  }\n\n  // pointer position from top left of the screen\n  public static movePointer(deltaX: number, deltaY: number) {\n    const scale = this.scale;\n    const { x: left, y: top } = this.screen;\n    this.data.pointer.x = left + deltaX / scale.x;\n    this.data.pointer.y = top + deltaY / scale.y;\n  }\n}\n","import React, {ReactNode} from \"react\";\nimport CanvasStore from \"../../modules/state/CanvasStore\";\nimport { inBounds } from \"./math-utils\";\n\nexport interface CanvasPosition {\n  top: number;\n  left: number;\n  width: number;\n  height: number;\n}\n\ntype PropsWithChildren<P> = P & { children?: ReactNode };\n\nexport const Position = ({\n  left,\n  top,\n  width,\n  height,\n  children\n}: PropsWithChildren<CanvasPosition>) => {\n  const screen = CanvasStore.screen;\n  if (\n    inBounds(\n      { left, top, height, width },\n      {\n        left: screen.x,\n        top: screen.y,\n        width: screen.width,\n        height: screen.height\n      }\n    )\n  ) {\n    return (\n      <div\n        className=\"absolute inline-block\"\n        style={{\n          left: `${left - screen.x}px`,\n          top: `${top - screen.y}px`\n        }}\n      >\n        {children}\n      </div>\n    );\n  } else return null;\n};\n","import React from \"react\";\nimport { RECT_H, RECT_W } from \"../../modules/core/constants\";\nimport { CanvasPosition, Position } from \"../../modules/core/foundation\";\nimport CanvasStore from \"../../modules/state/CanvasStore\";\nimport { memo } from \"react\";\n\ninterface TextBlockProps extends CanvasPosition {\n  text: string;\n  color: string;\n  width: number;\n  height: number;\n}\n\nconst TextBlock = ({\n  text,\n  color,\n  left,\n  top,\n  width,\n  height\n}: TextBlockProps) => {\n  return (\n    <Position left={left} top={top} width={width} height={height}>\n      <div\n        className=\"flex items-center justify-center\"\n        style={{\n          width: `${width}px`,\n          height: `${height}px`,\n          background: color\n        }}\n      >\n        {text}\n      </div>\n    </Position>\n  );\n};\n\nconst InfiniteCanvas = ({ frame }: { frame: string }) => {\n  function createCustomSequenceArray(sequence: Array<string>, length: number) {\n    const result = [];\n\n    for (let i = 0; i < length; i++) {\n      result.push(sequence[i % sequence.length]);\n    }\n\n    return result;\n  }\n\n  const arrayLength = 64;\n  const colorSequence = [\"#769656\", \"#eeeed2\", \"#baca44\"];\n  const textsSequence = [\n    \"Infinite Canvases Are Easy When You Know The Fundamentals\",\n    \"Canvases\",\n    \"Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\"\n  ];\n\n  const texts = createCustomSequenceArray(textsSequence, arrayLength);\n  const colors = createCustomSequenceArray(colorSequence, arrayLength);\n\n  const rectW = RECT_W;\n  const rectH = RECT_H;\n  const scale = CanvasStore.scale;\n\n  return (\n    <div\n      className=\"w-full h-full\"\n      style={{\n        transform: `scale(${(scale.x, scale.y)})`,\n        transformOrigin: \"top left\"\n      }}\n    >\n      {texts.map((text, index) => (\n        <TextBlock\n          key={index}\n          text={text}\n          color={colors[index]}\n          left={(index % 8) * rectW}\n          top={Math.floor(index / 8) * rectH}\n          width={rectW}\n          height={rectH}\n        />\n      ))}\n    </div>\n  );\n};\n\nexport default memo(InfiniteCanvas);\n","import React, { useEffect, useRef, WheelEvent } from \"react\";\nimport CanvasStore from \"../../modules/state/CanvasStore\";\nimport useSize from \"@react-hook/size\";\nimport InfiniteCanvas from \"./InfiniteCanvas\";\nimport useRenderLoop from \"../../modules/core/RenderLoop\";\n\nconst maxZoom = 165; // Figma: 25600%\nconst minZoom = -6000;\nlet currentZoom = 100;\n\nconst wheelListener = (e: WheelEvent) => {\n  const friction = 1;\n  const event = e as WheelEvent;\n  const deltaX = event.deltaX * friction;\n  const deltaY = event.deltaY * friction;\n  if (!event.ctrlKey) {\n    CanvasStore.moveCamera(deltaX, deltaY);\n  } else {\n\n    const isFeatureEnabled = false;\n\n    if (!isFeatureEnabled) {\n      CanvasStore.zoomCamera(deltaX, deltaY);\n    } else {\n      // TODO: zoom constraint\n      if (currentZoom <= maxZoom) {\n        currentZoom = currentZoom + -deltaY;\n      }\n      if (minZoom <= currentZoom) {\n        currentZoom = currentZoom + -deltaY;\n      }\n      console.log('!!!');\n      if ( minZoom <= currentZoom && currentZoom <= maxZoom) {\n        CanvasStore.zoomCamera(deltaX, deltaY);\n      } else {\n        if (currentZoom >= maxZoom) {\n          currentZoom = maxZoom\n        } else {\n          currentZoom = minZoom\n        }\n      }\n    }\n  }\n};\n\nconst pointerListener = (event: any) => {\n  console.log(event)\n  CanvasStore.movePointer(event.clientX, event.clientY);\n};\n\nconst CanvasRoot = () => {\n  const canvas = useRef<HTMLDivElement>(null);\n  const [width, height] = useSize(canvas);\n\n  useEffect(() => {\n    if (width === 0 || height === 0) return;\n    CanvasStore.initialize(width, height);\n  }, [width, height]);\n\n  const frame = useRenderLoop(60);\n\n  let isPointerDown = false;\n\n  const startPointerScroll = (event: any) => {\n    isPointerDown = true;\n    const startX = event.clientX;\n    const startY = event.clientY;\n\n    const scrollListener = (event: any) => {\n      if (isPointerDown) {\n        const deltaX = startX - event.clientX;\n        const deltaY = startY - event.clientY;\n        CanvasStore.moveCamera(deltaX, deltaY);\n      }\n    };\n\n    const stopScrollListener = () => {\n      isPointerDown = false;\n      document.removeEventListener(\"pointermove\", scrollListener);\n      document.removeEventListener(\"pointerup\", stopScrollListener);\n    };\n\n    document.addEventListener(\"pointermove\", scrollListener);\n    document.addEventListener(\"pointerup\", stopScrollListener);\n  };\n\n  return (\n      <div className=\"w-full h-full\">\n        <div\n            className=\"w-full h-full relative overflow-hidden overscroll-none\"\n            ref={canvas}\n            onWheel={wheelListener}\n            onPointerDown={startPointerScroll}\n            onPointerUp={() => {\n              isPointerDown = false;\n            }}\n            onPointerMove={pointerListener}\n        >\n          <InfiniteCanvas frame={frame}></InfiniteCanvas>\n        </div>\n      </div>\n  );\n};\n\nexport default CanvasRoot;","import React from \"react\";\nimport CanvasRoot from \"./CanvasRoot\";\n\nconst Editor = () => {\n  return (\n    <div className=\"w-full h-full\">\n      <CanvasRoot />\n    </div>\n  );\n};\n\nexport default Editor;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport Editor from \"./modules/editor/Editor\";\n\nReactDOM.render(<Editor />, document.getElementById(\"root\") as HTMLElement);\n"],"sourceRoot":""}